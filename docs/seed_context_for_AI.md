# DescriptiveCAD / AI_CADdie — Seed Context for Next Chat (v0.2)

Originally used as a seed document to bootstrap a **fresh chat 
session** so the assistant can continue development deterministically. Now 
it will be used to compare the tasks generated by the LLM in planning mode 
for the first plan to validate the development approach.

This doc will be delete after first working plan is accepted

## What you (the user) will do in the new chat
1. Upload the latest repo archive named **`input.zip`**.
2. Say: “Use `input.zip` as the source of truth. Continue development. Do not do work inline; return updated repo as `input.zip`.”
3. (Optional) Ask the assistant to run tests after each change and to describe changes at a high level.

## Repository purpose
A self-contained, open-source experiment to convert a **natural-language framing specification** into:
1) a canonical, machine-checkable **scene JSON**, then  
2) a rendered **OpenSCAD** file.

The near-term goal is **not** “LLM reads arbitrary URLs.” Instead:
- User uploads a repo zip + a spec.
- Assistant updates code + returns an updated repo zip and/or outputs (scene/scad) as downloadable files.

## Current state (as of this seed)
### Pipeline layers
A. **Registries + Schemas**
- JSON schemas validate prototypes/operators/scenes.
- Registries enumerate available prototype/operator “type strings” and their schema refs.

B. **Scene build / resolve**
- Scene is loaded, then **expanded**:
  - operators generate or mutate objects (or produce derived objects)
  - templates are expanded into concrete objects

C. **SCAD rendering**
- Renderer converts resolved objects to SCAD primitives (polygon/extrude, color, etc.)

### Prototypes implemented (examples)
- `room_regular_octagon` (anchor/boundary object)
- `poly_extrude` (arbitrary 2D footprint extruded to height)
- `dim_lumber_member`
  - Represents a framing member as a rectangular footprint extruded to height.
  - Supports `profile` as:
    - explicit actual dims, or
    - nominal + system resolved via `registry/lumber_profiles.json`.

### Operators implemented (examples)
- `clip_to_object` (clip a solid’s footprint to a boundary’s footprint)
- `extend_and_trim_to_object`
  - Implements “extend until intersects then trim flush” using a half-plane trim strategy.
- `distribute_evenly_between`
  - Generates N copies of a **template object** placed evenly between two reference objects.

## Key semantic rule added: Templates + provides
Problem solved: A user spec may omit fields (like a start point) because an operator supplies them (e.g., “middle sleepers spaced evenly”).

**Solution in scene JSON:**
- Objects can be declared as:
  - `role: "template"` (not rendered, not included in final resolved object list)
- Operators can declare what fields they supply via a **`provides`** mechanism:
  - e.g. the distribute operator provides `params.placement.start` for generated objects

**Deterministic contract:**
- Non-template objects must satisfy their full schema.
- Template objects may omit ONLY fields that an operator explicitly provides during expansion.
- Engine enforces this; LLM does not “invent” missing values.

## Testing
- Uses Python `unittest`.
- Standard command:
  - `python -m unittest discover -s tests -v`
- Tests exist for:
  - prototypes (shape correctness / registry resolution)
  - operators (geometry-only assertions; SCAD rendering not required)

## What still needs to be built (next development milestones)
The following are the remaining “big rocks” needed to model the original sunken-room framing spec using the new architecture.

### 1) Feature queries / anchor geometry helpers (high priority)
We need deterministic ways to place objects without raw coordinates:
- `point_on_wall_from_vertex` (e.g., “47 inches from North Vertex along the NE wall”)
- `wall_segment(name)` and `vertex(name)` accessors for polygonal anchors
- `direction` system for named directions (N, NE, …) consistently tied to the anchor’s coordinate frame

### 2) Group operators beyond distribute (high priority)
- `distribute_evenly_between` exists, but we still need:
  - “edge spacing by edges, not centers” option
  - distribution across an arbitrary span defined by two named boundaries
  - joist spacing at fixed on-center (e.g., 16\" o.c.) with exclusions/clearance zones

### 3) Robust trimming primitives (medium)
- Current trims use half-plane logic for “trim to first touch.”
- Need additional trim modes:
  - trim to boundary edge
  - trim with offset (clearance)
  - “stop short by X”
  - intersect with multiple boundaries (min of several constraints)

### 4) Scene validation wiring (medium)
Some schemas exist but may not all be enforced in the runtime path.
- Ensure scene loader validates:
  - object schemas
  - operator schemas
  - template/provides rules
- Remove duplicate schema files; keep one canonical:
  - recommended: `schemas/scene.schema.json`

### 5) Example scenes (medium/high)
Add compact example scenes for each operator/prototype:
- `examples/extend_and_trim_minimal.scene.json`
- add: `examples/distribute_evenly_minimal.scene.json`
- add: `examples/anchor_points_minimal.scene.json` (once helpers exist)

### 6) LLM “spec → scene.json” step (later, but plan now)
Goal: produce canonical scene blocks from a user spec without free-form inference.
- Use a strict mapping:
  - spec terms → prototype/operator type strings in registries
- Assistant should:
  1) extract or ask for missing info,
  2) produce a valid scene JSON,
  3) run pipeline and return SCAD.

## Non-goals (for now)
- No GUI
- No multi-room composition / external imports
- No textures (SCAD has color; textures aren’t a priority)
- No relying on external URL fetching for core workflow

## Operating instructions for the assistant in the new chat
- Treat the uploaded `input.zip` as the source of truth.
- Make changes only by modifying the repo and returning a new `input.zip`.
- Run `unittest` after changes and only return passing zips unless explicitly asked to deliver WIP.
- Keep responses short; do not paste large files inline.

## Notes on OpenSCAD
- Target OpenSCAD output as a render format.
- Geometry computations should happen in Python; SCAD should be “dumb rendering” where possible.

---
End of seed context.

import argparse, json, math
from typing import Any, Dict, List, Tuple, Optional

Point = Tuple[float, float]
Poly = List[Point]

def regular_octagon(span_flat_to_flat: float) -> Poly:
    a = span_flat_to_flat / 2.0
    s = 2*a*math.tan(math.pi/8)
    t = a - s/2.0
    return [(-t, a), (t, a), (a, t), (a, -t), (t, -a), (-t, -a), (-a, -t), (-a, t)]

def rect_footprint(center: Point, sx: float, sy: float) -> Poly:
    cx, cy = center
    hx, hy = sx/2.0, sy/2.0
    return [(cx-hx, cy-hy), (cx+hx, cy-hy), (cx+hx, cy+hy), (cx-hx, cy+hy)]

def sutherland_hodgman_halfplane(poly: Poly, a: Point, b: Point, keep_left: bool) -> Poly:
    def inside(p: Point) -> bool:
        ax, ay = a; bx, by = b; px, py = p
        cross = (bx-ax)*(py-ay) - (by-ay)*(px-ax)
        return cross >= -1e-9 if keep_left else cross <= 1e-9

    def intersect(p1: Point, p2: Point) -> Point:
        x1,y1 = p1; x2,y2 = p2
        x3,y3 = a;  x4,y4 = b
        den = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4)
        if abs(den) < 1e-12:
            return p2
        px = ((x1*y2 - y1*x2)*(x3-x4) - (x1-x2)*(x3*y4 - y3*x4)) / den
        py = ((x1*y2 - y1*x2)*(y3-y4) - (y1-y2)*(x3*y4 - y3*x4)) / den
        return (px, py)

    if not poly:
        return []
    out: Poly = []
    prev = poly[-1]
    prev_in = inside(prev)
    for cur in poly:
        cur_in = inside(cur)
        if cur_in:
            if not prev_in:
                out.append(intersect(prev, cur))
            out.append(cur)
        else:
            if prev_in:
                out.append(intersect(prev, cur))
        prev, prev_in = cur, cur_in
    return out

class Obj:
    def __init__(self, obj_id: str, obj_type: str, params: Dict[str, Any]):
        self.id = obj_id
        self.type = obj_type
        self.params = params
        self.footprint: Optional[Poly] = None
        self.z_base: float = 0.0
        self.height: float = float(params.get("height", 1.0))

def build_scad(objs: Dict[str, Obj], out_path: str) -> None:
    def poly_str(poly: Poly) -> str:
        return ", ".join([f"[{x:.6f},{y:.6f}]" for x,y in poly])

    with open(out_path, "w", encoding="utf-8") as f:
        f.write("// Generated by DescriptiveCAD v0.1\n")
        f.write("$fn=32;\n\n")
        for o in objs.values():
            if not o.footprint:
                continue
            f.write(f"translate([0,0,{o.z_base:.6f}]) linear_extrude(height={o.height:.6f}) ")
            f.write(f"polygon(points=[{poly_str(o.footprint)}]);\n")

def op_distribute_linear_array(scene: Dict[str, Any], objs: Dict[str, Obj], op: Dict[str, Any]) -> None:
    proto = objs[op["inputs"]["prototype"]]
    count = int(op["params"]["count"])
    y = float(op["params"]["y"])
    spacing_basis = op["params"].get("spacing_basis","center_to_center")
    room_poly = regular_octagon(scene["room"]["span_flat_to_flat"])
    xs = [p[0] for p in room_poly]
    x_min, x_max = min(xs), max(xs)

    sx, sy = float(proto.params["size"][0]), float(proto.params["size"][1])
    if count <= 0:
        return

    if spacing_basis == "clear_gap":
        total = count*sx
        gap = (x_max - x_min - total) / (count + 1)
        centers = [x_min + gap*(i+1) + sx*(i+0.5) for i in range(count)]
    else:
        step = (x_max - x_min) / (count + 1)
        centers = [x_min + step*(i+1) for i in range(count)]

    pref = op["outputs"]["prefix"]
    for i, cx in enumerate(centers, start=1):
        oid = f"{pref}{i}"
        o = Obj(oid, "member", dict(proto.params))
        o.footprint = rect_footprint((cx,y), sx, sy)
        objs[oid] = o

def op_clip_by_halfplane(scene: Dict[str, Any], objs: Dict[str, Obj], op: Dict[str, Any]) -> None:
    clipper = objs[op["inputs"]["clipper"]]
    if clipper.type == "hearth" and clipper.footprint is None:
        ox, oy = clipper.params["origin"]
        sx, sy = clipper.params["size"]
        clipper.footprint = [(ox,oy),(ox+sx,oy),(ox+sx,oy+sy),(ox,oy+sy)]
        clipper.height = float(clipper.params.get("height", clipper.height))

    if not clipper.footprint:
        return

    miny = min(p[1] for p in clipper.footprint)
    a = (-1e6, miny)
    b = ( 1e6, miny)  # directed east; left side is north

    keep = op["params"]["keep"]  # "south" keeps below => keep_left=False
    keep_left = False if keep == "south" else True

    targets_prefix = op["inputs"]["targets_prefix"]
    out_prefix = op["outputs"]["prefix"]
    idx = 1
    for oid, o in list(objs.items()):
        if oid.startswith(targets_prefix) and o.footprint:
            nid = f"{out_prefix}{idx}"
            idx += 1
            o2 = Obj(nid, o.type, dict(o.params))
            o2.footprint = sutherland_hodgman_halfplane(o.footprint, a, b, keep_left=keep_left)
            objs[nid] = o2

OPS = {
    "distribute_linear_array": op_distribute_linear_array,
    "clip_by_halfplane": op_clip_by_halfplane,
}

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("scene_json")
    ap.add_argument("--out", default="out.scad")
    args = ap.parse_args()

    with open(args.scene_json, "r", encoding="utf-8") as f:
        scene = json.load(f)

    if scene.get("version") != "0.1":
        raise SystemExit("Unsupported scene version")

    objs: Dict[str, Obj] = {}
    for o in scene["objects"]:
        objs[o["id"]] = Obj(o["id"], o["type"], o.get("params", {}))

    # seed hearth footprints
    for o in objs.values():
        if o.type == "hearth":
            ox, oy = o.params["origin"]
            sx, sy = o.params["size"]
            o.footprint = [(ox,oy),(ox+sx,oy),(ox+sx,oy+sy),(ox,oy+sy)]
            o.height = float(o.params.get("height", o.height))

    for op in scene["ops"]:
        fn = OPS.get(op["op"])
        if not fn:
            raise SystemExit(f"Unknown op: {op['op']}")
        fn(scene, objs, op)

    build_scad(objs, args.out)

if __name__ == "__main__":
    main()
